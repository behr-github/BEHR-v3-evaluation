function [ dataBlock, dataUnit, fullName, fullCat, tVec, modelName, modelRes, dataScale, molMass, tEdge ] = readBPCHSingle( inputFile,targCat,targID,tracerInfo,diagInfo,verbose,bruteForce,stayOpen,closeFile )
%READBPCHSINGLE Retrieves information from BPCH file for a single tracer
%   Extracts data from a BPCH file as generated by GEOS-Chem. Files
%   which can be read are:
%       ctm.bpch:           Primary GC output file
%       tsYYYYMMDD.bpch:    ND49 timeseries output
%       restart.bpch:       GC restart files
%   Input arguments (default values in brackets, where appropriate):
%       inputFile:          Filepath of the BPCH file
%       targCat:            Sanitised target category name (e.g. 'IJ_AVG')
%       targID:             Sanitised target tracer ID (e.g. 'NOx')
%       tracerInfo:         Filepath of the tracerinfo.dat file
%                           (<simulation directory>/tracerinfo.dat)
%       diagInfo:           Filepath of the diaginfo.dat file
%                           (<simulation directory>/diaginfo.dat)
%       verbose:           	(T)/F: Show all warnings
%       bruteForce:         T/(F): Ignore non-fatal fclose(fileID);errors
%   Default tracerinfo and/or diaginfo files are used if:
%       i)   Relevant argument is given as 'default', or
%       ii)  Relevant argument is an empty array, or
%       iii) Relevant argument is not given

persistent fileMap
dataStored = false;
makeHashTable = false;

if ~exist('stayOpen','var')
    stayOpen = false;
end

if stayOpen
    if isempty(fileMap)
        makeHashTable = true;
    elseif fileMap.isKey(inputFile)
        dataStored = true;
    end
end

if ~exist('closeFile','var');
    % Check if targCat is a close argument (overloaded function)
    if strcmpi(targCat,'close')
        closeFile = true;
    else
        closeFile = false;
    end
end

if closeFile
    % Call is just to close the file
    fclose(fileMap(inputFile));
    remove(fileMap,{inputFile});
    dataBlock = [];
    return;
end

if ~exist('verbose','var')
    verbose = false;
end
if ~exist('bruteForce','var')
    bruteForce = false;
end

defaultTracerInfo = true;
if exist('tracerInfo','var') && ~isempty(tracerInfo) && ~strcmpi(tracerInfo,'default')
    defaultTracerInfo = false;
end

defaultDiagInfo = true;
if exist('diagInfo','var') && ~isempty(diagInfo) && ~strcmpi(diagInfo,'default')
    defaultDiagInfo = false;
end

if defaultTracerInfo
    % Use tracerinfo.dat from same folder as input file
    tracerInfo = inputFile;
    % Change all backslashes into slashes
    tracerInfo(regexp(tracerInfo,'\')) = '/';
    tracerEnd=regexp(tracerInfo,'/');
    if ~isempty(tracerEnd)
        tracerInfo=sprintf('%stracerinfo.dat',tracerInfo(1:tracerEnd(end)));
    end
end

if defaultDiagInfo
    % Use diaginfo.dat from same folder as input file
    diagInfo = inputFile;
    % Change all backslashes into slashes
    diagInfo(regexp(diagInfo,'\')) = '/';
    diagEnd=regexp(diagInfo,'/');
    if ~isempty(diagEnd)
        diagInfo=sprintf('%sdiaginfo.dat',diagInfo(1:diagEnd(end)));
    end
end
    
% Check that files exist
if ~exist(inputFile,'file')
    error('BPCHRead:MissingTarget','BPCH input file ''%s'' not found.',inputFile);
elseif ~exist(tracerInfo,'file')
    error('BPCHRead:MissingTracerInfo','Tracer data file not found.');
elseif ~exist(diagInfo,'file')
    error('BPCHRead:MissingDiagInfo','Diagnostics data file not found.');
end

% Open file
if dataStored
    fileID = fileMap(inputFile);
else
    fileID = fopen(inputFile,'r','ieee-be');
    if stayOpen
        if makeHashTable
            % Establish hash table
            fileMap = containers.Map({inputFile},{fileID});
        else
            % Just add key
            fileMap(inputFile) = {fileID};
        end
    end
end

% Get header information
%[fileType,~,rOK_A] = readFORTRANRecord(fileID,'*char',1);
[~,~,rOK_A] = readFORTRANRecord(fileID,'*char',1);
%fileType = strtrim(fileType');
[titleLine,~,rOK_B] = readFORTRANRecord(fileID,'*char',1);
titleLine = strtrim(titleLine');
testRead(rOK_A & rOK_B);

% Check that we recognise the title line
knownTitlesLC={'geos-chem diag49 instantaneous timeseries','geos-chem binary punch file v. 2.0',...
	'geos-chem adj file: instantaneous adjoint concentrations'};

if verbose && (~sum(strcmpi(titleLine,knownTitlesLC)))
    warning('BPCHRead:UnknownFileType','File type ''%s'' not recognised; attempting to parse.',titleLine);
end

% Store this position - will need to rewind to it
dataStartPos = ftell(fileID);

%% Read in data to establish main data structure

% First line of the header of the first datablock
%[rOK,modelName,modelRes,halfPolar,centre180]=...
%    readFixedFORTRANRecord(fileID,'*char',20,'*float32',2,'*int32',1,'*int32',1);
[~,modelName,modelRes]=...
    readFixedFORTRANRecord(fileID,'*char',20,'*float32',2,'*int32',1,'*int32',1);

% Read tracer database
[tID,tName,tWeight,~,tNum,tScale,tUnit] = readTracerData(tracerInfo);
numTracers = length(tWeight);

% Read diagnostics information
[dOffset,dName,dFull] = readDiagInfo(diagInfo);
numDiags = length(dOffset);

%% Sanitise field names
% Some diagnostics and tracer have names that won't work as MATLAB fields
% Convert these to safe strings for field names
dNameSafe = dName;
for iDiag = 1:numDiags
    safeStr = char(dName{iDiag});
    if ~(isempty(regexp(safeStr,'-\$', 'once')) && isempty(regexp(safeStr,'=\$', 'once')))
        % Last two characters are -$ or =$
        safeStr = safeStr(1:end-2);
    end
    safeStr(regexp(safeStr,'\$')) = '';
    safeStr(regexp(safeStr,')')) = '';
    safeStr(regexp(safeStr,'(')) = '';
    safeStr(regexp(safeStr,'-')) = '_';
    safeStr(regexp(safeStr,' ')) = '_';
    % Ensure that the start of the category name is valid
    safeStr = ['C_' safeStr]; %#ok<AGROW>
    if ~isvarname(safeStr)
        if ~bruteForce
            fclose(fileID);
            error('BPCHRead:FieldSanity','Could not produce safe field name for diagnostic category %s (attempted ''%s'').',char(dName{iDiag}),safeStr);
        elseif verbose
            warning('BPCHRead:FieldSanity','Could not produce safe field name for diagnostic category %s (attempted ''%s''). Ignoring error.',char(dName{iDiag}),safeStr);
        end
    end
    dNameSafe(iDiag) = {safeStr};
end
% Determine index corresponding to target tracer
targCatNum = find(strcmpi(targCat,dNameSafe), 1);
if isempty(targCatNum)
    % May or may not have put a 'C_' in front...
    testCat = ['C_' targCat];
    targCatNum = find(strcmpi(testCat,dNameSafe), 1);
    if isempty(targCatNum)
        if bruteForce
            % Look in unsanitised category names
            targCatNum = find(strcmpi(targCat,dName), 1);
            if isempty(targCatNum)
                fclose(fileID);
                error('BPCHRead:UnknownCategory','Could not find category ''%s'' in sanitised or unsanitised field names.',targCat);
            elseif verbose
                warning('BPCHRead:UnsanitisedCategoryName','Could not find category ''%s'' in sanitised field names; using match ''%s'' from unsanitised field names.',targCat,dName{targCatNum});
            end
        else
            fclose(fileID);
            error('BPCHRead:UnknownCategory','Could not find category ''%s'' in sanitised field names.',targCat);
        end
    end
end

fullCat = dFull{targCatNum};

tIDSafe = tID;
for iTracer = 1:numTracers
    safeStr = char(tID{iTracer});
    safeStr(regexp(safeStr,'\$')) = '';
    safeStr(regexp(safeStr,')')) = '';
    safeStr(regexp(safeStr,'(')) = '';
    safeStr(regexp(safeStr,'-')) = '_';
    safeStr(regexp(safeStr,' ')) = '_';
    % Ensure that the start of the category name is valid
    safeStr = ['T_' safeStr]; %#ok<AGROW>
    if ~isvarname(safeStr)
        if ~bruteForce
            fclose(fileID);
            error('BPCHRead:FieldSanity','Could not produce safe field name for tracer %s (attempted ''%s'').',char(tID{iTracer}),safeStr);
        elseif verbose
            warning('BPCHRead:FieldSanity','Could not produce safe field name for tracer %s (attempted ''%s''). Ignoring error.',char(tID{iTracer}),safeStr);
        end
    end
    tIDSafe(iTracer) = {safeStr};
end

% Determine tracer index
%targIDNum = find(strcmpi(targID,tIDSafe), 1);
targIDNum = find(strcmpi(targID,tIDSafe));
if isempty(targIDNum)
    % May or may not have put a 'T_' in front...
    testID = ['T_' targID];
    %targIDNum = find(strcmpi(testID,tIDSafe), 1);
    targIDNum = find(strcmpi(testID,tIDSafe));
    %-----SDE DEBUG
    %fprintf('%s',tIDSafe{:});
    %-----SDE DEBUG
    if isempty(targIDNum)
        if bruteForce
            % Look in unsanitised category names
            %targIDNum = find(strcmpi(targID,tID), 1);
            targIDNum = find(strcmpi(targID,tID));
            if isempty(targCatNum)
                fclose(fileID);
                error('BPCHRead:UnknownTracer','Could not find tracer ''%s'' in sanitised or unsanitised field names.',targID);
            elseif verbose
                warning('BPCHRead:UnsanitisedTracerName','Could not find tracer ''%s'' in sanitised field names; using match ''%s'' from unsanitised field names.',targID,tID{targIDNum});
            end
        else
            fclose(fileID);
            error('BPCHRead:UnknownTracer','Could not find tracer ''%s'' in sanitised field names.',targID);
        end
    end
end

if isempty(targIDNum)
    fclose(fileID);
    error('BPCHRead:UnknownTracer','Could not find tracer ''%s'' in sanitised or unsanitised field names.',targID);
end

% Are there multiple target IDs?
if length(targIDNum) > 1
    % Find the one corresponding to this category
    tempID = tNum(targIDNum) - dOffset(targCatNum);
    tempID(tempID<0) = max(tempID) + 1;
    [~,newIdx] = min(tempID);
    targIDNum = targIDNum(newIdx);
end

%modelData = struct('hRes',[latRes longRes],'name',modelName,...
%    'hPolar',halfPolar,'c180',centre180,'longE',longEVec,'latE',latEVec,...
%    'longC',longCVec,'latC',latCVec,'numAlts',numAlts);
%tracerStruct = struct('data',0,'dims',[],...
%    'start',[],'weight',0,'carbon',0,'unit','','datenum',0);
%ctmData.modelData = modelData;

% Set metadata
dataUnit = tUnit{targIDNum};
fullName = tName{targIDNum};

%% Read datablocks
% Rewind to start of data (returns 0 if successful, -1 otherwise)
if fseek(fileID,dataStartPos,-1)
    fclose(fileID);
    error('Could not rewind to start of data blocks.');
end
fileComplete = false;

% First pass - determine length of data
% Assume no more than 1e6 pieces of data
readLocs = zeros(1e6,1);
numEntries = 0;
tDims = [];
currLoc = ftell(fileID);
fseek(fileID,0,1);
endLoc = ftell(fileID);
fseek(fileID,currLoc,-1);
catMissing = false;

if verbose
    fprintf('Scanning tracer blocks to determine entry size.\n');
end

if bruteForce
    badTracers = ones(numTracers,1).*(-1);
    badCounter = 0;
end

% Make a first pass at the time vector
tVec = readLocs;
tEdge = zeros(length(tVec)+1,1);

while ~fileComplete
    % Header lines - formatting taken direct from website
    %[ROk1,MName,MRes,HPolar,C180]...
        %=readFixedFORTRANRecord(fileID,'*char',20,'*float32',2,'*int32',1,'*int32',1);
    % First line: model name, model resolution, and data concerning
    % formatting. We are assuming that this data will be the same
    % throughout the file, and has already been acquired.
    readFORTRANRecord(fileID,'seekpast');
    % Second line: information about the tracer itself.
    %   Diagnostic category name
    %   Tracer number
    %   Unit string (e.g. ppbv)
    %   Starting date (tau value - hours since 1/1/1985)
    %   Ending date
    %   Unused string
    %   Dimensions - NI, NJ, NL, I0, J0, L0
    %   Length of data block in bytes
    
    [readOK,diagCat,tracer,~,startTau,endTau,~,dataDim,~]...
        =readFixedFORTRANRecord(fileID,'*char',40,'*int32',1,'*char',40,...
        '*float64',1,'*float64',1,'*char',40,'*int32',6,'*int32',1);
    
    if (~(bruteForce || readOK) && (numEntries > 0))
        % Stop reading but return partial data
        fileComplete = true;
        warning('readBPCHSingle:partialRead','File corrupt or incomplete; partial data returned.');
    else
        testRead(readOK,bruteForce);
        if readOK
            diagCat = strtrim(diagCat');
            catIndex = find(strcmp(diagCat,dName));
            if ~isempty(catIndex)
                tracer = tracer + dOffset(catIndex);
                tracIndex = find(tNum==tracer);
            else
                tracIndex = [];
            end
            if isempty(tracIndex)
                if (verbose && bruteForce)
                    if ~sum(badTracers == tracer)
                        badCounter = badCounter + 1;
                        badTracers(badCounter) = tracer;
                        warning('BPCHRead:MissingTracer','Tracer information file missing data for tracer number %i; skipping tracer.',tracer);
                    end
                elseif ~bruteForce
                    error('BPCHRead:MissingTracer','Tracer information file missing data for tracer number %i; aborting.',tracer);
                end
            else
                if isempty(catIndex)
                    % No categories
                    if ~catMissing
                        if verbose
                            warning('BPCHRead:NoCategories','No categories found.');
                        end
                        % Reduce size of category matrices to 1 category
                    end
                    catMissing = true;
                    catIndex = 1;
                end
                if ((tracIndex == targIDNum) && (catIndex == targCatNum))
                    numEntries = numEntries + 1;
                    readLocs(numEntries) = ftell(fileID);
                    if isempty(tDims)
                        numDims = max(sum(dataDim~=1),1);
                        tDims = dataDim(1:numDims)';
                    end
                    % Calculate sample time
                    % startTau and endTau: hours since 1/1/1985
                    startTau = (startTau/24) + datenum(1985,1,1,0,0,0);
                    endTau = (endTau/24) + datenum(1985,1,1,0,0,0);
                    if numEntries == 1
                        tEdge(numEntries) = startTau;
                    end
                    tEdge(numEntries+1) = endTau;
                    tVec(numEntries) = (startTau + endTau)/2;
                end
            end
        end
        % Skip actual data, as cannot yet efficiently allocate memory
        readFORTRANRecord(fileID,'seekpast');
        currLoc = ftell(fileID);
        locDelta = endLoc - currLoc;
        if locDelta == 0
            fileComplete = true;
        end
    end
end

tVec = tVec(1:numEntries);
tEdge = tEdge(1:(numEntries+1));
readLocs = readLocs(1:numEntries);
if ~numEntries
    fclose(fileID);
    error('BPCHRead:NoData','Could not find any relevant data in BPCH file.');
end

if verbose
    fprintf('Data scanning complete. Retrieving datablocks...\n');
end

% Now read in real data
dataBlock = zeros([tDims,numEntries]);
dataScale = tScale(targIDNum);
molMass = tWeight(targIDNum);
%miniVec = @(x) (x(:));
for iEntry = 1:numEntries
    fseek(fileID,readLocs(iEntry),-1);
    indexArray = cell(1,numDims+1);
    indexArray(1:numDims) = {':'};
    indexArray(end) = {iEntry};
    dataBlock(indexArray{:}) = dataScale .* reshape(readFORTRANRecord(fileID,'*float32',4),tDims);
    %if any(isnan(miniVec(dataBlock)))
    %    warning('readBPCHSingle:badData','Bad data found');
    %end
end

if ~stayOpen
    fclose(fileID);
end

    function []=testRead(readOK,forceFile)
        if ~readOK
            if ~forceFile
                fclose(fileID);
                error('Read fclose(fileID);error in file %s.\n',inputFile);
            else
                warning('Read fclose(fileID);error in file %s.\n',inputFile);
            end
        end
    end

end

